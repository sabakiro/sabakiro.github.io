<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="Hexo">
  <link 
    rel="icon" 
    href="/">
  <title>tokio_2</title>
  
    
      <meta 
        property="og:title" 
        content="tokio_2">
    
    
      <meta 
        property="og:url" 
        content="https://sabakiro.github.io/2023/08/26/tokio-2/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://s1.ax1x.com/2023/07/26/pCvilc9.jpg">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2023-08-26">
      <meta 
        property="og:article:modified_time" 
        content="2023-08-27">
      <meta 
        property="og:article:author" 
        content="sabakiro">
      
        
          <meta 
            property="og:article:tag" 
            content="rust">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
      <span class="navbar-logo-dsc">kaze</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          Friends
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://s1.ax1x.com/2023/07/26/pCvilc9.jpg" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">sabakiro</p>
<p class="author-description">none</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>61</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>0</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>9</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bytes%E4%BE%9D%E8%B5%96%E5%8C%85"><span class="toc-text">bytes依赖包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">状态同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">提前释放锁:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9D%A5%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81"><span class="toc-text">使用异步任务和消息传递来管理状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Tokio%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-text">使用Tokio提供的异步锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93"><span class="toc-text">创建消息通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6"><span class="toc-text">对消息通道进行限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-text">read</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read"><span class="toc-text">AsyncReadExt::read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read-to-end"><span class="toc-text">AsyncReadExt::read_to_end</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-text">write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncWriteExt-write"><span class="toc-text">AsyncWriteExt::write</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%99%A8"><span class="toc-text">读写分离器</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/rust/" 
        title="rust">
        <div class="tags-list-item">rust</div>
      </a>
    
      <a 
        href="/tags/vue/" 
        title="vue">
        <div class="tags-list-item">vue</div>
      </a>
    
      <a 
        href="/tags/c/" 
        title="c#">
        <div class="tags-list-item">c#</div>
      </a>
    
      <a 
        href="/tags/linux/" 
        title="linux">
        <div class="tags-list-item">linux</div>
      </a>
    
      <a 
        href="/tags/go/" 
        title="go">
        <div class="tags-list-item">go</div>
      </a>
    
      <a 
        href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" 
        title="数据结构">
        <div class="tags-list-item">数据结构</div>
      </a>
    
      <a 
        href="/tags/%E7%AE%97%E6%B3%95/" 
        title="算法">
        <div class="tags-list-item">算法</div>
      </a>
    
      <a 
        href="/tags/flutter/" 
        title="flutter">
        <div class="tags-list-item">flutter</div>
      </a>
    
      <a 
        href="/tags/golang/" 
        title="golang">
        <div class="tags-list-item">golang</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      tokio_2
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2023-08-26T04:18:03.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2023-08-26</span>
    </time>
    
    
      <span class="dot"></span>
      <span>2.6k words</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/rust/" 
            class="post-meta-link">
            rust
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h2 id="bytes依赖包"><a href="#bytes依赖包" class="headerlink" title="bytes依赖包"></a>bytes依赖包</h2><pre class="highlight"><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bytes</span> = <span class="string">&quot;1&quot;</span></span><br></pre>
<p>使用 <code>Vec&lt;u8&gt;</code> 来保存目标数据，<br>但是它有一个问题，<br>对它进行克隆时会将底层数据也整个复制一份，<br>效率很低，<br>但是克隆操作对于我们在多连接间共享数据又是必不可少的。</p>
<p>引入一个 bytes 包，它包含一个 Bytes 类型，<br>当对该类型的值进行克隆时，就不再会克隆底层数据。<br>事实上，Bytes 是一个引用计数类型，<br>跟 Arc 非常类似，或者准确的说，<br>Bytes 就是基于 Arc 实现的，<br>但相比后者Bytes 提供了一些额外的能力</p>
<pre class="highlight"><span class="line"><span class="comment">//起别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Db</span> = Arc&lt;Mutex&lt;HashMap&lt;<span class="type">String</span>, Bytes&gt;&gt;&gt;;</span><br></pre>

<p>在使用 Tokio 编写异步代码时，<br>一个常见的错误无条件地使用 tokio::sync::Mutex ，<br>而真相是：<code>Tokio 提供的异步锁只应该在跨多个 .await调用时使用</code>，<br>而且 Tokio 的 Mutex 实际上内部使用的也是 std::sync::Mutex。</p>
<p>多补充几句，在异步代码中，关于锁的使用有以下经验之谈：</p>
<ol>
<li>锁如果在多个 .await 过程中持有，应该使用 Tokio 提供的锁，<br> 原因是 .await的过程中锁可能在线程间转移，<br> 若使用标准库的同步锁存在死锁的可能性，<br> 例如某个任务刚获取完锁，还没使用完就因为 .await 让出了当前线程的所有权，<br> 结果下个任务又去获取了锁，造成死锁</li>
<li>锁竞争不多的情况下，使用 <code>std::sync::Mutex</code></li>
<li>锁竞争多，可以考虑使用三方库提供的性能更高的锁，例如 <code>parking_lot::Mutex</code></li>
</ol>
<p>当竞争不多的时候，使用阻塞性的锁去保护共享数据是一个正确的选择。<br>当一个锁竞争触发后，当前正在执行任务(请求锁)的线程会被阻塞，<br>并等待锁被前一个使用者释放。</p>
<p>默认情况下，Tokio 调度器使用了多线程模式，<br>此时如果有大量的任务都需要访问同一个锁，<br>那么锁竞争将变得激烈起来。<br>当然，你也可以使用 <code>current_thread</code> 运行时设置，<br>在该设置下会使用一个单线程的调度器(执行器)，<br>所有的任务都会创建并执行在当前线程上，<br>因此不再会有锁竞争</p>
<p>current_thread 是一个轻量级、单线程的运行时，<br>当任务数不多或连接数不多时是一个很好的选择。<br>例如想在一个异步客户端库的基础上<br>提供给用户同步的 API 访问时，该模式就很适用</p>
<p>当同步锁的竞争变成一个问题时，<br>使用 Tokio 提供的异步锁几乎并不能帮你解决问题，<br>此时可以考虑如下选项：</p>
<ol>
<li>创建专门的任务并使用消息传递的方式来管理状态</li>
<li>将锁进行分片</li>
<li>重构代码以避免锁</li>
</ol>
<h2 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h2><h5 id="提前释放锁"><a href="#提前释放锁" class="headerlink" title="提前释放锁:"></a>提前释放锁:</h5><p>可以把 Mutex 放入一个结构体中，<br>并且只在该结构体的非异步方法中使用该锁:</p>
<pre class="highlight"><span class="line"><span class="keyword">struct</span> <span class="title class_">CanIncrement</span> &#123;</span><br><span class="line">    mutex: Mutex&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CanIncrement</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法不是 `async`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">increment</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = <span class="keyword">self</span>.mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *lock += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">increment_and_do_stuff</span>(can_incr: &amp;CanIncrement) &#123;</span><br><span class="line">	<span class="comment">//该方法不是 `async`</span></span><br><span class="line">	can_incr.<span class="title function_ invoke__">increment</span>();</span><br><span class="line">	<span class="title function_ invoke__">do_something_async</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre>
<h4 id="使用异步任务和消息传递来管理状态"><a href="#使用异步任务和消息传递来管理状态" class="headerlink" title="使用异步任务和消息传递来管理状态"></a>使用异步任务和消息传递来管理状态</h4><p>常常用于共享的资源是 I&#x2F;O 类型的资源</p>
<h5 id="使用Tokio提供的异步锁"><a href="#使用Tokio提供的异步锁" class="headerlink" title="使用Tokio提供的异步锁"></a>使用Tokio提供的异步锁</h5><p>Tokio 提供的锁最大的优点就是：<br>它可以在 .await 执行期间被持有，<br>而且不会有任何问题。<br>但是代价就是，这种异步锁的性能开销会更高，<br>因此如果可以，使用之前的两种方法来解决会更好</p>
<pre class="highlight"><span class="line"><span class="keyword">use</span> tokio::sync::Mutex; <span class="comment">// 注意，这里使用的是 Tokio 提供的锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会编译</span></span><br><span class="line"><span class="comment">// 但是就这个例子而言，之前的方式会更好</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">increment_and_do_stuff</span>(mutex: &amp;Mutex&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">    *lock += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">do_something_async</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125; <span class="comment">// 锁在这里被释放</span></span><br></pre>

<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>Tokio 提供了多种消息通道，可以满足不同场景的需求:</p>
<ol>
<li>mpsc, 多生产者，单消费者模式</li>
<li>oneshot, 单生产者单消费，一次只能发送一条消息</li>
<li>broadcast，多生产者，多消费者，<br>其中每一条发送的消息都可以被所有接收者收到，因此是广播</li>
<li>watch，单生产者，多消费者，只保存一条最新的消息，<br>因此接收者只能看到最近的一条消息，<br>例如，这种模式适用于配置文件变化的监听</li>
<li>多生产者、多消费者，且每一条消息只能被其中一个消费者接收，<br>如果有这种需求，可以使用 <code>async-channel</code> 包。</li>
</ol>
<h3 id="创建消息通道"><a href="#创建消息通道" class="headerlink" title="创建消息通道"></a>创建消息通道</h3><pre class="highlight"><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新通道，缓冲队列长度是 32</span></span><br><span class="line">    <span class="comment">//可以使用 clone 方法克隆多个发送者，</span></span><br><span class="line">    <span class="comment">//但是接收者无法被克隆，因为该通道是 mpsc 类型</span></span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">32</span>);</span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;sending from first handle&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx2.<span class="title function_ invoke__">send</span>(<span class="string">&quot;sending from second handle&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	当所有的发送者都被 Drop 掉后(超出作用域或</span></span><br><span class="line"><span class="comment">	被 drop(...) 函数主动释放)，</span></span><br><span class="line"><span class="comment">	就不再会有任何消息发送给该通道，</span></span><br><span class="line"><span class="comment">	此时 recv 方法将返回 None，也意味着该通道已经被关闭。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(message) = rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<p>如果消息发送的比接收的快，<br>这些消息将被存储在缓冲队列中，<br>一旦存满了 32 条消息，<br>使用send(…).await的发送者会进入睡眠，<br>直到缓冲队列可以放入新的消息</p>
<p>往<code>oneshot</code>中发送消息时，并<code>没有使用 .await</code>，<br>原因是该发送操作要么直接成功、要么失败，并不需要等待。</p>
<h3 id="对消息通道进行限制"><a href="#对消息通道进行限制" class="headerlink" title="对消息通道进行限制"></a>对消息通道进行限制</h3><p>我们都需要<code>对缓存队列的长度进行限制</code>，<br>这样系统才能优雅的处理各种负载状况。<br>如果不限制，假设接收端无法及时处理消息，<br>那<code>消息就会迅速堆积</code>，最终可能会导致<code>内存消耗殆尽</code>，<br>就算内存没有消耗完，也可能会导致<code>整体性能的大幅下降</code>。</p>
<p>Tokio 在设计时就考虑了这种状况，<br>例如 async 操作在 Tokio 中是惰性的:</p>
<pre class="highlight"><span class="line"><span class="comment">//非惰性</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">async_op</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    async_op 不是惰性的，而是在每次循环时立即执行，</span></span><br><span class="line"><span class="comment">    那该循环会立即将一个 async_op 发送到缓冲队列中，</span></span><br><span class="line"><span class="comment">    然后开始执行下一个循环，因为无需等待任务执行完成，</span></span><br><span class="line"><span class="comment">    这种发送速度是非常恐怖的，</span></span><br><span class="line"><span class="comment">    一秒钟可能会有几十万、上百万的消息发送到消息队列中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//惰性</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// 当前 `async_op` 完成后，才会开始下一次循环</span></span><br><span class="line">    <span class="title function_ invoke__">async_op</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 Async Rust 和 Tokio 中，</span></span><br><span class="line"><span class="comment">上面的代码 async_op 根本就不会运行，</span></span><br><span class="line"><span class="comment">也就不会往消息队列中写入消息。</span></span><br><span class="line"><span class="comment">原因是我们没有调用 .await，</span></span><br><span class="line"><span class="comment">就算使用了 .await 上面的代码也不会有问题，</span></span><br><span class="line"><span class="comment">因为只有等当前循环的任务结束后，才会开始下一次循环。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre>
<p>在 Tokio 中我们必须要显式地引入并发和队列:</p>
<ol>
<li>tokio::spawn</li>
<li>select!</li>
<li>join!</li>
<li>mpsc::channel<br>需要小心的控制并发度来确保系统的安全。<br>例如，当使用一个循环去接收 TCP 连接时，<br>你要确保当前打开的 socket 数量在可控范围内，<br>而不是毫无原则的接收连接。</li>
</ol>
<p>再比如，当使用 mpsc::channel 时，要设置一个缓冲值。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><h4 id="AsyncReadExt-read"><a href="#AsyncReadExt-read" class="headerlink" title="AsyncReadExt::read"></a>AsyncReadExt::read</h4><p>一个异步方法可以将数据读入缓冲区( buffer )中，<br>然后返回读取的字节数。</p>
<pre class="highlight"><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 buffer 的长度限制，当次的 `read` 调用最多可以从文件中读取 10 个字节的数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = f.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer[..]).<span class="keyword">await</span>?;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 read 返回 Ok(0) 时，意味着字节流( stream )已经关闭，</span></span><br><span class="line"><span class="comment">在这之后继续调用 read 会立刻完成，依然获取到返回值 Ok(0)。 </span></span><br><span class="line"><span class="comment">例如，字节流如果是 TcpStream 类型，</span></span><br><span class="line"><span class="comment">那 Ok(0) 说明该连接的读取端已经被关闭(写入端关闭，会报其它的错误)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The bytes: &#123;:?&#125;&quot;</span>, &amp;buffer[..n]);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre>
<h4 id="AsyncReadExt-read-to-end"><a href="#AsyncReadExt-read-to-end" class="headerlink" title="AsyncReadExt::read_to_end"></a>AsyncReadExt::read_to_end</h4><p>从字节流中读取所有的字节，直到遇到 EOF</p>
<pre class="highlight"><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取整个文件的内容</span></span><br><span class="line">    f.<span class="title function_ invoke__">read_to_end</span>(&amp;<span class="keyword">mut</span> buffer).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre>

<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><h4 id="AsyncWriteExt-write"><a href="#AsyncWriteExt-write" class="headerlink" title="AsyncWriteExt::write"></a>AsyncWriteExt::write</h4><p>尝试将缓冲区的内容写入到写入器( writer )中，<br>同时返回写入的字节数:</p>
<pre class="highlight"><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = file.<span class="title function_ invoke__">write</span>(<span class="string">b&quot;some bytes&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Wrote the first &#123;&#125; bytes of &#x27;some bytes&#x27;.&quot;</span>, n);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre>
<h3 id="读写分离器"><a href="#读写分离器" class="headerlink" title="读写分离器"></a>读写分离器</h3><p>读写器( reader + writer )都可以使用 io::split 方法进行分离，<br>最终返回一个读取器和写入器，这两者可以独自的使用</p>
<pre class="highlight"><span class="line">......</span><br><span class="line"><span class="keyword">let</span> <span class="variable">socket</span> = TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:6142&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> (<span class="keyword">mut</span> rd, <span class="keyword">mut</span> wr) = io::<span class="title function_ invoke__">split</span>(socket);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">io::split 可以用于任何同时实现了 AsyncRead 和</span></span><br><span class="line"><span class="comment"> AsyncWrite 的值，</span></span><br><span class="line"><span class="comment">它的内部使用了 Arc 和 Mutex 来实现相应的功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">......</span><br></pre>
<p>比io::split更加轻量的读写分离器<br>TcpStream::split会获取字节流的引用，然后将其分离成一个读取器和写入器。<br>    但由于使用了引用的方式，它们俩必须和 split 在同一个任务中。<br>    优点就是，这种实现没有性能开销，因为无需 Arc 和 Mutex。<br>TcpStream::into_split还提供了一种分离实现，分离出来的结果可以在任务间移动，<br>    内部是通过 Arc 实现</p>
<p>示例：<br>由于 io::copy() 调用时所在的任务和 split 所在的任务是同一个，<br>因此可以使用性能最高的 TcpStream::split</p>
<pre class="highlight"><span class="line">tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> rd, <span class="keyword">mut</span> wr) = socket.<span class="title function_ invoke__">split</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> rd, &amp;<span class="keyword">mut</span> wr).<span class="keyword">await</span>.<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;failed to copy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            sabakiro
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://sabakiro.github.io/2023/08/26/tokio-2/">
            https://sabakiro.github.io/2023/08/26/tokio-2/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2023/08/27/tokio-3/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">Prev</div>
          
            <div class="nav-title">tokio_3 帧 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2023/08/26/tokio-1/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">tokio_1 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bytes%E4%BE%9D%E8%B5%96%E5%8C%85"><span class="toc-text">bytes依赖包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">状态同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">提前释放锁:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9D%A5%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81"><span class="toc-text">使用异步任务和消息传递来管理状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Tokio%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-text">使用Tokio提供的异步锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93"><span class="toc-text">创建消息通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6"><span class="toc-text">对消息通道进行限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-text">read</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read"><span class="toc-text">AsyncReadExt::read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read-to-end"><span class="toc-text">AsyncReadExt::read_to_end</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-text">write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncWriteExt-write"><span class="toc-text">AsyncWriteExt::write</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%99%A8"><span class="toc-text">读写分离器</span></a></li></ol></li></ol>
</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bytes%E4%BE%9D%E8%B5%96%E5%8C%85"><span class="toc-text">bytes依赖包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">状态同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">提前释放锁:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9D%A5%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81"><span class="toc-text">使用异步任务和消息传递来管理状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Tokio%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-text">使用Tokio提供的异步锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93"><span class="toc-text">创建消息通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6"><span class="toc-text">对消息通道进行限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-text">read</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read"><span class="toc-text">AsyncReadExt::read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncReadExt-read-to-end"><span class="toc-text">AsyncReadExt::read_to_end</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-text">write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncWriteExt-write"><span class="toc-text">AsyncWriteExt::write</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%99%A8"><span class="toc-text">读写分离器</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-18</div>
        <a href="/2023/09/18/go-1/"><div class="recent-posts-item-content">go_1</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-17</div>
        <a href="/2023/09/17/%E5%9B%BE/"><div class="recent-posts-item-content">图</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-15</div>
        <a href="/2023/09/15/vue%E8%B7%AF%E7%94%B1%E5%92%8Cpinia%E5%9F%BA%E7%A1%80/"><div class="recent-posts-item-content">vue路由和pinia基础</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-14</div>
        <a href="/2023/09/14/vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/"><div class="recent-posts-item-content">vue深入组件</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2023
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          kaze
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    href="#"
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
