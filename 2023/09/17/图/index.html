<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="Hexo">
  <link 
    rel="icon" 
    href="/">
  <title>图</title>
  
    
      <meta 
        property="og:title" 
        content="图">
    
    
      <meta 
        property="og:url" 
        content="https://sabakiro.github.io/2023/09/17/%E5%9B%BE/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://s1.ax1x.com/2023/07/26/pCvilc9.jpg">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2023-09-17">
      <meta 
        property="og:article:modified_time" 
        content="2023-09-24">
      <meta 
        property="og:article:author" 
        content="sabakiro">
      
        
          <meta 
            property="og:article:tag" 
            content="数据结构">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
      <span class="navbar-logo-dsc">kaze</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          Friends
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://s1.ax1x.com/2023/07/26/pCvilc9.jpg" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">sabakiro</p>
<p class="author-description">none</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>64</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>0</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>11</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">邻接表遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E9%81%8D%E5%8E%86"><span class="toc-text">邻接矩阵遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="toc-text">Prim算法(针对稠密图)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="toc-text">Kruskal算法(针对稀疏图)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">关键路径</span></a></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/rust/" 
        title="rust">
        <div class="tags-list-item">rust</div>
      </a>
    
      <a 
        href="/tags/vue/" 
        title="vue">
        <div class="tags-list-item">vue</div>
      </a>
    
      <a 
        href="/tags/c/" 
        title="c#">
        <div class="tags-list-item">c#</div>
      </a>
    
      <a 
        href="/tags/go/" 
        title="go">
        <div class="tags-list-item">go</div>
      </a>
    
      <a 
        href="/tags/linux/" 
        title="linux">
        <div class="tags-list-item">linux</div>
      </a>
    
      <a 
        href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" 
        title="数据结构 算法">
        <div class="tags-list-item">数据结构 算法</div>
      </a>
    
      <a 
        href="/tags/json/" 
        title="json">
        <div class="tags-list-item">json</div>
      </a>
    
      <a 
        href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" 
        title="数据结构">
        <div class="tags-list-item">数据结构</div>
      </a>
    
      <a 
        href="/tags/%E7%AE%97%E6%B3%95/" 
        title="算法">
        <div class="tags-list-item">算法</div>
      </a>
    
      <a 
        href="/tags/flutter/" 
        title="flutter">
        <div class="tags-list-item">flutter</div>
      </a>
    
      <a 
        href="/tags/golang/" 
        title="golang">
        <div class="tags-list-item">golang</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      图
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2023-09-17T07:03:46.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2023-09-17</span>
    </time>
    
    
      <span class="dot"></span>
      <span>4.7k words</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" 
            class="post-meta-link">
            数据结构
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h1 id="邻接表遍历"><a href="#邻接表遍历" class="headerlink" title="邻接表遍历"></a>邻接表遍历</h1><pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GraphNode</span>() &#123;&#125;</span><br><span class="line">	~<span class="built_in">GraphNode</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">GraphNode</span>(<span class="type">int</span> label) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;label = label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//元素下标</span></span><br><span class="line">	<span class="type">int</span> label;</span><br><span class="line">	<span class="comment">//存储表元素</span></span><br><span class="line">	std::vector&lt;GraphNode*&gt;neighbors;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_Graph</span><span class="params">(GraphNode*node, <span class="type">int</span> visit[])</span> </span>&#123;</span><br><span class="line">	std::queue&lt;GraphNode*&gt;Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(node);</span><br><span class="line">	<span class="comment">//设置标记位</span></span><br><span class="line">	visit[node-&gt;label] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		GraphNode*node = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; node-&gt;label;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (visit[node-&gt;neighbors[i]-&gt;label] == <span class="number">0</span>) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;neighbors[i]);</span><br><span class="line">				visit[node-&gt;neighbors[i]-&gt;label] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Graph</span><span class="params">(GraphNode*node, <span class="type">int</span> vist[])</span> </span>&#123;</span><br><span class="line">	vist[node-&gt;label] = <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; node-&gt;label;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vist[node-&gt;neighbors[i]-&gt;label] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">DFS_Graph</span>(node-&gt;neighbors[i], vist);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5</span>;</span><br><span class="line">	GraphNode*Graph[MAX];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Graph[i] = <span class="keyword">new</span> <span class="built_in">GraphNode</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	Graph[<span class="number">0</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">4</span>]);</span><br><span class="line">	Graph[<span class="number">0</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">2</span>]);</span><br><span class="line">	Graph[<span class="number">1</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">0</span>]);</span><br><span class="line">	Graph[<span class="number">1</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">2</span>]);</span><br><span class="line">	Graph[<span class="number">2</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">3</span>]);</span><br><span class="line">	Graph[<span class="number">3</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">4</span>]);</span><br><span class="line">	Graph[<span class="number">4</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph[<span class="number">3</span>]);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	0: 4 2</span></span><br><span class="line"><span class="comment">	1: 0 2</span></span><br><span class="line"><span class="comment">	2: 3</span></span><br><span class="line"><span class="comment">	3: 4</span></span><br><span class="line"><span class="comment">	4: 3</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> visit[MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (visit[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;from label [&quot;</span> &lt;&lt; Graph[i]-&gt;label &lt;&lt; <span class="string">&quot;] :&quot;</span>;</span><br><span class="line">			<span class="built_in">BFS_Graph</span>(Graph[i], visit);</span><br><span class="line">			std::cout &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;----------------------------------\n&quot;</span>;</span><br><span class="line">	GraphNode*Graph1[MAX];</span><br><span class="line">	<span class="type">int</span> visit1[MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Graph1[i] = <span class="keyword">new</span> <span class="built_in">GraphNode</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	Graph1[<span class="number">0</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">4</span>]);</span><br><span class="line">	Graph1[<span class="number">0</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">2</span>]);</span><br><span class="line">	Graph1[<span class="number">1</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">0</span>]);</span><br><span class="line">	Graph1[<span class="number">1</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">2</span>]);</span><br><span class="line">	Graph1[<span class="number">2</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">3</span>]);</span><br><span class="line">	Graph1[<span class="number">3</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">4</span>]);</span><br><span class="line">	Graph1[<span class="number">4</span>]-&gt;neighbors.<span class="built_in">push_back</span>(Graph1[<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (visit1[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;from label [&quot;</span> &lt;&lt; Graph1[i]-&gt;label &lt;&lt; <span class="string">&quot;] :&quot;</span>;</span><br><span class="line">			<span class="built_in">DFS_Graph</span>(Graph1[i], visit1);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">from label [0] : 0 4 2 3</span></span><br><span class="line"><span class="comment">from label [1] : 1</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">from label [0] : 0 4 3 2</span></span><br><span class="line"><span class="comment">from label [1] : 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre>

<h1 id="邻接矩阵遍历"><a href="#邻接矩阵遍历" class="headerlink" title="邻接矩阵遍历"></a>邻接矩阵遍历</h1><pre class="highlight"><span class="line"> </span><br><span class="line">Boolean visited[MAXVEX]; <span class="comment">/* 访问标志的数组 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵的深度优先递归算法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"> 	visited[i] = TRUE;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G.vexs[i]);<span class="comment">/* 打印顶点，也可以其它操作 */</span></span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes; j++)</span><br><span class="line">		<span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line"> 			DFS(G, j);<span class="comment">/* 对为访问的邻接顶点递归调用 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵的深度遍历操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(MGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line"> 		visited[i] = FALSE; <span class="comment">/* 初始所有顶点状态都是未访问过状态 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line"> 		<span class="keyword">if</span>(!visited[i]) <span class="comment">/* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */</span> </span><br><span class="line">			DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵的广度遍历算法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(MGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	Queue Q;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">       	visited[i] = FALSE;</span><br><span class="line">    InitQueue(&amp;Q);		<span class="comment">/* 初始化一辅助用的队列 */</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)  <span class="comment">/* 对每一个顶点做循环 */</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i])	<span class="comment">/* 若是未访问过就处理 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			visited[i]=TRUE;		<span class="comment">/* 设置当前顶点访问过 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G.vexs[i]);<span class="comment">/* 打印顶点，也可以其它操作 */</span></span><br><span class="line">			EnQueue(&amp;Q,i);		<span class="comment">/* 将此顶点入队列 */</span></span><br><span class="line">			<span class="keyword">while</span>(!QueueEmpty(Q))	<span class="comment">/* 若当前队列不为空 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				DeQueue(&amp;Q,&amp;i);	<span class="comment">/* 将队对元素出队列，赋值给i */</span></span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++) </span><br><span class="line">				&#123; </span><br><span class="line">					<span class="comment">/* 判断其它顶点若与当前顶点存在边且未访问过  */</span></span><br><span class="line">					<span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) </span><br><span class="line">					&#123; </span><br><span class="line"> 						visited[j]=TRUE;	<span class="comment">/* 将找到的此顶点标记为已访问 */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G.vexs[j]);	<span class="comment">/* 打印顶点 */</span></span><br><span class="line">						EnQueue(&amp;Q,j);				<span class="comment">/* 将找到的此顶点入队列  */</span></span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h5 id="Prim算法-针对稠密图"><a href="#Prim算法-针对稠密图" class="headerlink" title="Prim算法(针对稠密图)"></a>Prim算法(针对稠密图)</h5><pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 20 <span class="comment">//邻接矩阵大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPH_INFINITY 10086<span class="comment">//表示无限大</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">	<span class="comment">//顶点数，边数</span></span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.用邻接矩阵第一行的数据初始化</span></span><br><span class="line"><span class="comment">2.找到最小权重</span></span><br><span class="line"><span class="comment">3.用下一行的数据初始化</span></span><br><span class="line"><span class="comment">4.重复步骤2，3。直至所有点都执行过一遍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph&amp; g)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> adjvex[MAXVEX];<span class="comment">/* 保存相关顶点下标 */</span></span><br><span class="line">	<span class="type">int</span> lowcost[MAXVEX];<span class="comment">/* 保存相关顶点间边的权值 */</span></span><br><span class="line">	<span class="comment">/* 初始化第一个权值为0，即v0加入生成树</span></span><br><span class="line"><span class="comment">	lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/</span></span><br><span class="line">	lowcost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 初始化第一个顶点下标为0 */</span></span><br><span class="line">	adjvex[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 循环除下标为0外的全部顶点 */</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>; i &lt; g.numVertexes; i++)</span><br><span class="line">	&#123;<span class="comment">/* 将v0顶点与之有边的权值存入数组 */</span></span><br><span class="line">		lowcost[i] = g.arc[<span class="number">0</span>][i];</span><br><span class="line">		adjvex[i] = <span class="number">0</span>;<span class="comment">/* 初始化都为v0的下标 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////////////////   初始化工作完成  //////////////////////////</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; g.numVertexes; i++)&#123;</span><br><span class="line">		min = GRAPH_INFINITY;<span class="comment">/* 初始化最小权值为∞， */</span></span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;<span class="comment">/*用来循环最小权值的顶点下标*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;g.numVertexes;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* j 用来做顶点下标循环的变量*/</span></span><br><span class="line">			<span class="keyword">if</span> (lowcost[j]!=<span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = lowcost[j];<span class="comment">/* 则让当前权值成为最小值 */</span></span><br><span class="line">				k = j;<span class="comment">/* 将当前最小值的下标存入k ,k为下一个顶点*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, adjvex[k], k);<span class="comment">/* 打印当前顶点边中权值最小的边 */</span></span><br><span class="line">		lowcost[k] = <span class="number">0</span>;<span class="comment">/* 将当前顶点的权值设置为0,表示此顶点已经完成任务-&gt;避免重复 */</span></span><br><span class="line">		<span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt; g.numVertexes; j++)&#123;</span><br><span class="line">		<span class="comment">//重新初始化lowcost.如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 </span></span><br><span class="line">			<span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.arc[k][j] &lt; lowcost[j]) &#123;</span><br><span class="line">				lowcost[j] = g.arc[k][j];<span class="comment">/* 将较小的权值存入lowcost相应位置 */</span></span><br><span class="line">				adjvex[j] = k;<span class="comment">/* 将下标为k的顶点存入adjvex */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	MGraph g=<span class="built_in">MGraph</span>();</span><br><span class="line">	g.numEdges = <span class="number">15</span>;</span><br><span class="line">	g.numVertexes = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				g.arc[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g.arc[i][j] = g.arc[j][i] = GRAPH_INFINITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.arc[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">	g.arc[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">11</span>;</span><br><span class="line">	g.arc[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">18</span>;</span><br><span class="line">	g.arc[<span class="number">1</span>][<span class="number">8</span>] = <span class="number">12</span>;</span><br><span class="line">	g.arc[<span class="number">1</span>][<span class="number">6</span>] = <span class="number">16</span>;</span><br><span class="line">	g.arc[<span class="number">2</span>][<span class="number">8</span>] = <span class="number">8</span>;</span><br><span class="line">	g.arc[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">22</span>;</span><br><span class="line">	g.arc[<span class="number">3</span>][<span class="number">8</span>] = <span class="number">21</span>;</span><br><span class="line">	g.arc[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">24</span>;</span><br><span class="line">	g.arc[<span class="number">3</span>][<span class="number">7</span>] = <span class="number">16</span>;</span><br><span class="line">	g.arc[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">20</span>;</span><br><span class="line">	g.arc[<span class="number">4</span>][<span class="number">7</span>] = <span class="number">7</span>;</span><br><span class="line">	g.arc[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">26</span>;</span><br><span class="line">	g.arc[<span class="number">5</span>][<span class="number">6</span>] = <span class="number">17</span>;</span><br><span class="line">	g.arc[<span class="number">6</span>][<span class="number">7</span>] = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.numVertexes; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; g.numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			g.arc[j][i] = g.arc[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MiniSpanTree_Prim</span>(g);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>
<h5 id="Kruskal算法-针对稀疏图"><a href="#Kruskal算法-针对稀疏图" class="headerlink" title="Kruskal算法(针对稀疏图)"></a>Kruskal算法(针对稀疏图)</h5><pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPH_INFINITY 10086</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> begin;</span><br><span class="line">	<span class="type">int</span> end;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;;<span class="comment">/* 对边集数组Edge结构的定义 */</span></span><br><span class="line"><span class="comment">/* 交换权值 以及头和尾 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swapn</span><span class="params">(Edge *edges, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	temp = edges[i].begin;</span><br><span class="line">	edges[i].begin = edges[j].begin;</span><br><span class="line">	edges[j].begin = temp;</span><br><span class="line">	temp = edges[i].end;</span><br><span class="line">	edges[i].end = edges[j].end;</span><br><span class="line">	edges[j].end = temp;</span><br><span class="line">	temp = edges[i].weight;</span><br><span class="line">	edges[i].weight = edges[j].weight;</span><br><span class="line">	edges[j].weight = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对权值进行排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Edge edges[], MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numEdges; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; G-&gt;numEdges; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (edges[i].weight &gt; edges[j].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swapn</span>(edges, i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;权排序之后的为:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numEdges; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) %d\n&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查找连线顶点的尾部下标 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> *parent, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[f] &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f = parent[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(MGraph&amp;g)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.权重排序</span></span><br><span class="line"><span class="comment">2.判断十分存在环</span></span><br><span class="line"><span class="comment">3.不存在环则添加到parent数组中</span></span><br><span class="line"><span class="comment">4.重复步骤2，3。直到结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 定义一数组用来判断边与边是否形成环路 </span></span><br><span class="line"><span class="comment">	一点与下一点之间没有直接相连路径的情况下，</span></span><br><span class="line"><span class="comment">	该点映射在 parent 数组上的值为0，最后一个点除外*/</span></span><br><span class="line">	<span class="type">int</span> parent[MAXVEX]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */</span></span><br><span class="line">	Edge edges[MAXEDGE];</span><br><span class="line">	<span class="comment">/* 用来构建边集数组并排序 -&gt; 无向图，所以只需要保留一半*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.numVertexes<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; g.numVertexes; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (g.arc[i][j]&lt;GRAPH_INFINITY)</span><br><span class="line">			&#123;</span><br><span class="line">				edges[k].begin = i;</span><br><span class="line">				edges[k].end = j;</span><br><span class="line">				edges[k++].weight = g.arc[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges, &amp;g);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;打印最小生成树：\n&quot;</span>;</span><br><span class="line">	<span class="comment">/* 循环每一条边 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.numEdges; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n = <span class="built_in">Find</span>(parent, edges[i].begin);</span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">Find</span>(parent, edges[i].end);</span><br><span class="line">		<span class="comment">/* 假如n与m不等，说明此边没有与现有的生成树形成环路 */</span></span><br><span class="line">		<span class="keyword">if</span> (n!=m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 将此边的结尾顶点放入下标为起点的parent中。</span></span><br><span class="line"><span class="comment">			表示此顶点已经在生成树集合中*/</span></span><br><span class="line">			parent[n] = m;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) %d \n&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(4,7) 7</span></span><br><span class="line"><span class="comment">(2,8) 8</span></span><br><span class="line"><span class="comment">(0,1) 10</span></span><br><span class="line"><span class="comment">(0,5) 11</span></span><br><span class="line"><span class="comment">(1,8) 12</span></span><br><span class="line"><span class="comment">(3,7) 16</span></span><br><span class="line"><span class="comment">(1,6) 16</span></span><br><span class="line"><span class="comment">(6,7) 19</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre>

<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>Dijkstra</p>
<pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPH_INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> vexs[MAXVEX];</span><br><span class="line">	<span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MAXVEX];    <span class="comment">/* 用于存储最短路径下标的数组 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX];<span class="comment">/* 用于存储到各点最短路径的权值和 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构件图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* printf(&quot;请输入边数和顶点数:&quot;); */</span></span><br><span class="line">	G-&gt;numEdges = <span class="number">16</span>;</span><br><span class="line">	G-&gt;numVertexes = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		G-&gt;vexs[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				G-&gt;arc[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G-&gt;arc[i][j] = G-&gt;arc[j][i] = GRAPH_INFINITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">6</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">5</span>][<span class="number">7</span>] = <span class="number">5</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">6</span>][<span class="number">7</span>] = <span class="number">2</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">6</span>][<span class="number">8</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">7</span>][<span class="number">8</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G-&gt;arc[j][i] = G-&gt;arc[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */</span></span><br><span class="line"><span class="comment">/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(MGraph G, <span class="type">int</span> v0, Patharc *P, ShortPathTable *D)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.计算出下一个顶点</span></span><br><span class="line"><span class="comment">2.计算 a-&gt;b-&gt;c 和 a-&gt;c 的距离进行比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">int</span> k; <span class="type">int</span> final[MAXVEX]=&#123;<span class="number">0</span>&#125;;<span class="comment">/* final[w]=1表示求得顶点v0至vw的最短路径 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.numVertexes; v++)    <span class="comment">/* 初始化数据 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*D)[v] = G.arc[v0][v];<span class="comment">/* 将与v0点有连线的顶点加上权值 */</span></span><br><span class="line">		(*P)[v] = <span class="number">-1</span>;				<span class="comment">/* 初始化路径数组P为-1  */</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*D)[v0] = <span class="number">0</span>;  <span class="comment">/* v0至v0路径为0 */</span></span><br><span class="line">	final[v0] = <span class="number">1</span>;    <span class="comment">/* v0至v0不需要求路径 */</span></span><br><span class="line">	<span class="comment">/* 开始主循环，每次求得v0到某个v顶点的最短路径 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt; G.numVertexes; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> min = GRAPH_INFINITY;    <span class="comment">/* 当前所知离v0顶点的最近距离 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.numVertexes; w++) <span class="comment">/* 寻找离v0最近的顶点 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!final[w] &amp;&amp; (*D)[w] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				k = w;</span><br><span class="line">				min = (*D)[w];    <span class="comment">/* w顶点离v0顶点更近 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		final[k] = <span class="number">1</span>;    <span class="comment">/* 将目前找到的最近的顶点置为1 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.numVertexes; w++) <span class="comment">/* 修正当前最短路径及距离 */</span></span><br><span class="line">		&#123;	<span class="comment">/* 如果经过v顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line"><span class="comment">			(*D)[w]表示该层</span></span><br><span class="line"><span class="comment">			min + G.arc[k][w]表示最小路径与下一层</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (!final[w] &amp;&amp; (min + G.arc[k][w] &lt; (*D)[w]))</span><br><span class="line">			&#123; <span class="comment">/*  说明找到了更短的路径，修改D[w]和P[w] */</span></span><br><span class="line">				(*D)[w] = min + G.arc[k][w];  <span class="comment">/* 修改当前路径长度 */</span></span><br><span class="line">				(*P)[w] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, v0;</span><br><span class="line">	MGraph G;</span><br><span class="line">	Patharc P;</span><br><span class="line">	ShortPathTable D; <span class="comment">/* 求某点到其余各点的最短路径 */</span></span><br><span class="line">	v0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	CreateMGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">	ShortestPath_Dijkstra(G, v0, &amp;P, &amp;D);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最短路径倒序如下:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.numVertexes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;v%d - v%d : &quot;</span>, v0, i);</span><br><span class="line">		j = i;</span><br><span class="line">		<span class="keyword">while</span> (P[j] != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, P[j]);</span><br><span class="line">			j = P[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n源点到各顶点的最短路径长度为:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.numVertexes; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;v%d - v%d : %d \n&quot;</span>, G.vexs[<span class="number">0</span>], G.vexs[i], D[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre>

<p>Floyd</p>
<pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPH_INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> vexs[MAXVEX];</span><br><span class="line">	<span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构件图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* printf(&quot;请输入边数和顶点数:&quot;); */</span></span><br><span class="line">	G-&gt;numEdges = <span class="number">16</span>;</span><br><span class="line">	G-&gt;numVertexes = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		G-&gt;vexs[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				G-&gt;arc[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G-&gt;arc[i][j] = G-&gt;arc[j][i] = GRAPH_INFINITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">6</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">5</span>][<span class="number">7</span>] = <span class="number">5</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">6</span>][<span class="number">7</span>] = <span class="number">2</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">6</span>][<span class="number">8</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">7</span>][<span class="number">8</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G-&gt;arc[j][i] = G-&gt;arc[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyd</span><span class="params">(MGraph G, Patharc *P, ShortPathTable *D)</span></span><br><span class="line">&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 a点直接到c点的权值和a到b再到c的权值和作比较，</span></span><br><span class="line"><span class="comment">	 如果a-&gt;c &gt; a-&gt; b -&gt;c ，则a-&gt;c的权值等于 a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) <span class="comment">/* 初始化D与P */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			(*D)[v][w] = G.arc[v][w];	<span class="comment">/* D[v][w]值即为对应点间的权值 */</span></span><br><span class="line">			(*P)[v][w] = w;				<span class="comment">/* 初始化P */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.numVertexes; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> ((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w])</span><br><span class="line">				&#123;<span class="comment">/* 如果经过下标为k顶点路径比原两点间路径更短 */</span></span><br><span class="line">					(*D)[v][w] = (*D)[v][k] +(*D)[k][w];<span class="comment">/*将当前两点间权值设为更小的一个*/</span></span><br><span class="line">					(*P)[v][w] = (*P)[v][k];<span class="comment">/* 路径设置为经过下标为k的顶点 */</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> v, w, k;</span><br><span class="line">	MGraph G;</span><br><span class="line"></span><br><span class="line">	Patharc P;</span><br><span class="line">	ShortPathTable D; <span class="comment">/* 求某点到其余各点的最短路径 */</span></span><br><span class="line"></span><br><span class="line">	CreateMGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">	ShortestPath_Floyd(G, &amp;P, &amp;D);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;各顶点间最短路径如下:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (w = v + <span class="number">1</span>; w &lt; G.numVertexes; w++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d weight: %d &quot;</span>, v, w, D[v][w]);</span><br><span class="line">			k = P[v][w];				<span class="comment">/* 获得第一个路径顶点下标 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; path: %d&quot;</span>, v);	<span class="comment">/* 打印源点 */</span></span><br><span class="line">			<span class="keyword">while</span> (k != w)				<span class="comment">/* 如果路径顶点下标不是终点 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, k);	<span class="comment">/* 打印路径顶点 */</span></span><br><span class="line">				k = P[k][w];			<span class="comment">/* 获得下一个路径顶点下标 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d\n&quot;</span>, w);	<span class="comment">/* 打印终点 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最短路径D\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, D[v][w]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最短路径P\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, P[v][w]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEDGE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> vexs[MAXVEX];</span><br><span class="line">	<span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表结构****************** */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> /* 边表结点  */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;    <span class="comment">/* 邻接点域，存储该顶点对应的下标 */</span></span><br><span class="line">	<span class="type">int</span> weight;		<span class="comment">/* 用于存储权值，对于非网图可以不需要 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span> <span class="comment">/* 链域，指向下一个邻接点 */</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> /* 顶点表结点 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> in;	<span class="comment">/* 顶点入度 */</span></span><br><span class="line">	<span class="type">int</span> data; <span class="comment">/* 顶点域，存储顶点信息 */</span></span><br><span class="line">	EdgeNode *firstedge;<span class="comment">/* 边表头指针 */</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AdjList adjList; <span class="comment">/*邻接表*/</span></span><br><span class="line">	<span class="type">int</span> numVertexes, numEdges; <span class="comment">/* 图中当前顶点数和边数 */</span></span><br><span class="line">&#125;graphAdjList, *GraphAdjList;</span><br><span class="line"><span class="comment">/* **************************** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span><span class="comment">/* 构件图 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* printf(&quot;请输入边数和顶点数:&quot;); */</span></span><br><span class="line">	G-&gt;numEdges = MAXEDGE;</span><br><span class="line">	G-&gt;numVertexes = MAXVEX;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		G-&gt;vexs[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)<span class="comment">/* 初始化图 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G-&gt;arc[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">0</span>][<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">1</span>][<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">2</span>][<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">3</span>][<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">4</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">5</span>][<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">5</span>][<span class="number">12</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">8</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">9</span>][<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">9</span>][<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">10</span>][<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">	G-&gt;arc[<span class="number">12</span>][<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 利用邻接矩阵构建邻接表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateALGraph</span><span class="params">(MGraph G, GraphAdjList *GL)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	EdgeNode *e;</span><br><span class="line"></span><br><span class="line">	*GL = (GraphAdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphAdjList));</span><br><span class="line"></span><br><span class="line">	(*GL)-&gt;numVertexes = G.numVertexes;</span><br><span class="line">	(*GL)-&gt;numEdges = G.numEdges;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++) <span class="comment">/* 读入顶点信息，建立顶点表 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*GL)-&gt;adjList[i].in = <span class="number">0</span>;</span><br><span class="line">		(*GL)-&gt;adjList[i].data = G.vexs[i];</span><br><span class="line">		(*GL)-&gt;adjList[i].firstedge = <span class="literal">NULL</span>; 	<span class="comment">/* 将边表置为空表 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++) <span class="comment">/* 建立边表 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.numVertexes; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arc[i][j] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				e = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">				e-&gt;adjvex = j;					<span class="comment">/* 邻接序号为j  */</span></span><br><span class="line">				<span class="comment">/*将当前顶点上的指向的结点指针赋值给e */</span></span><br><span class="line">				e-&gt;next = (*GL)-&gt;adjList[i].firstedge;</span><br><span class="line">				(*GL)-&gt;adjList[i].firstedge = e;	<span class="comment">/* 将当前顶点的指针指向e  */</span></span><br><span class="line">				(*GL)-&gt;adjList[j].in++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 拓扑排序，若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;<span class="comment">/*从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，</span></span><br><span class="line"><span class="comment">并删除以此顶点为尾的弧，继续重复此步骤，</span></span><br><span class="line"><span class="comment">直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。*/</span></span><br><span class="line">	EdgeNode *e;</span><br><span class="line">	<span class="type">int</span> top = <span class="number">0</span>;  <span class="comment">/* 用于栈指针下标  */</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;<span class="comment">/* 用于统计输出顶点的个数  */</span></span><br><span class="line">	<span class="type">int</span> *<span class="built_in">stack</span>;	<span class="comment">/* 建栈将入度为0的顶点入栈  */</span></span><br><span class="line">	<span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == GL-&gt;adjList[i].in) <span class="comment">/* 将入度为0的顶点入栈 */</span></span><br><span class="line">			<span class="built_in">stack</span>[++top] = i;</span><br><span class="line">	<span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> gettop = <span class="built_in">stack</span>[top--];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, GL-&gt;adjList[gettop].data);</span><br><span class="line">		count++;        <span class="comment">/* 输出i号顶点，并计数 */</span></span><br><span class="line">		<span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e != <span class="literal">NULL</span>; e = e-&gt;next) &#123;<span class="comment">//遍历邻接表</span></span><br><span class="line">			<span class="type">int</span> k = e-&gt;adjvex;<span class="comment">//获取下标</span></span><br><span class="line">			<span class="comment">/* 将i号顶点的邻接点的入度减1，如果减1后为0，则入栈 */</span></span><br><span class="line">			<span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))</span><br><span class="line">				<span class="built_in">stack</span>[++top] = k;<span class="comment">/* 将入度为0的顶点入栈 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (count &lt; GL-&gt;numVertexes) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	GraphAdjList GL;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	CreateMGraph(&amp;G);</span><br><span class="line">	CreateALGraph(G, &amp;GL);</span><br><span class="line">	result = TopologicalSort(GL);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%d&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre>

<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><pre class="highlight"><span class="line"></span><br></pre>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            sabakiro
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://sabakiro.github.io/2023/09/17/%E5%9B%BE/">
            https://sabakiro.github.io/2023/09/17/%E5%9B%BE/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2023/09/18/go-1/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">Prev</div>
          
            <div class="nav-title">go_1 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2023/09/15/vue%E8%B7%AF%E7%94%B1%E5%92%8Cpinia%E5%9F%BA%E7%A1%80/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">vue路由和pinia基础 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">邻接表遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E9%81%8D%E5%8E%86"><span class="toc-text">邻接矩阵遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="toc-text">Prim算法(针对稠密图)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="toc-text">Kruskal算法(针对稀疏图)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">关键路径</span></a></li></ol>
</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">邻接表遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E9%81%8D%E5%8E%86"><span class="toc-text">邻接矩阵遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="toc-text">Prim算法(针对稠密图)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95-%E9%92%88%E5%AF%B9%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="toc-text">Kruskal算法(针对稀疏图)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">关键路径</span></a></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-24</div>
        <a href="/2023/09/24/json/"><div class="recent-posts-item-content">json</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-24</div>
        <a href="/2023/09/24/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"><div class="recent-posts-item-content">线索二叉树查找算法</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-24</div>
        <a href="/2023/09/24/go-2/"><div class="recent-posts-item-content">go-2</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-18</div>
        <a href="/2023/09/18/go-1/"><div class="recent-posts-item-content">go_1</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2023
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          kaze
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    href="#"
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
